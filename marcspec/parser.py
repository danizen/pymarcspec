#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class MarcSpecBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(MarcSpecBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class MarcSpecParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=MarcSpecBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(MarcSpecParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @tatsumasu()
    def _start_(self):  # noqa
        self._marcSpec_()
        self._check_eof()

    @tatsumasu()
    def _alphaupper_(self):  # noqa
        self._pattern('[A-Z]')

    @tatsumasu()
    def _alphalower_(self):  # noqa
        self._pattern('[a-z]')

    @tatsumasu()
    def _digit_(self):  # noqa
        self._pattern('[0-9]')

    @tatsumasu()
    def _vchar_(self):  # noqa
        self._pattern('[\\x21-\\x7a]')

    @tatsumasu()
    def _positiveDigit_(self):  # noqa
        self._pattern('[1-9]')

    @tatsumasu()
    def _positiveInt_(self):  # noqa
        self._pattern('[0-9]+')

    @tatsumasu()
    def _fieldTag_(self):  # noqa
        with self._choice():
            with self._option():
                self._pattern('[a-z0-9\\.]{3}')
            with self._option():
                self._pattern('[A-z0-9\\.]{3}')
            self._error('no available options')

    @tatsumasu()
    def _position_(self):  # noqa
        with self._choice():
            with self._option():
                self._positiveInt_()
            with self._option():
                self._token('#')
            self._error('no available options')

    @tatsumasu()
    def _range_(self):  # noqa
        self._position_()
        self.name_last_node('start')
        self._token('-')
        self._cut()
        self._position_()
        self.name_last_node('end')
        self.ast._define(
            ['end', 'start'],
            []
        )

    @tatsumasu()
    def _positionOrRange_(self):  # noqa
        with self._choice():
            with self._option():
                self._range_()
                self.name_last_node('range')
            with self._option():
                self._position_()
                self.name_last_node('pos')
            self._error('no available options')
        self.ast._define(
            ['pos', 'range'],
            []
        )

    @tatsumasu()
    def _CHARSPEC_(self):  # noqa
        self._token('/')
        self._cut()
        self._positionOrRange_()

    @tatsumasu()
    def _INDEX_(self):  # noqa
        self._token('[')
        self._positionOrRange_()
        self._token(']')

    @tatsumasu()
    def _fieldSpec_(self):  # noqa
        self._fieldTag_()
        self.name_last_node('tag')
        with self._optional():
            self._INDEX_()
            self.name_last_node('index')
        with self._optional():
            self._CHARSPEC_()
            self.name_last_node('cspec')
        self.ast._define(
            ['cspec', 'index', 'tag'],
            []
        )

    @tatsumasu()
    def _abrFieldSpec_(self):  # noqa
        with self._choice():
            with self._option():
                self._INDEX_()
                self.name_last_node('index')
                with self._optional():
                    self._CHARSPEC_()
                    self.name_last_node('cspec')
            with self._option():
                self._CHARSPEC_()
                self.name_last_node('cspec')
            self._error('no available options')
        self.ast._define(
            ['cspec', 'index'],
            []
        )

    @tatsumasu()
    def _subfieldChar_(self):  # noqa
        self._pattern('[a-z0-9]')

    @tatsumasu()
    def _subfieldCode_(self):  # noqa
        self._token('$')
        self._subfieldChar_()
        self.name_last_node('code')
        self.ast._define(
            ['code'],
            []
        )

    @tatsumasu()
    def _subfieldRange_(self):  # noqa
        self._token('$')
        self._subfieldChar_()
        self.name_last_node('start')
        self._token('-')
        self._subfieldChar_()
        self.name_last_node('end')
        self.ast._define(
            ['end', 'start'],
            []
        )

    @tatsumasu()
    def _abrSubfieldSpec_(self):  # noqa
        with self._group():
            with self._choice():
                with self._option():
                    self._subfieldRange_()
                    self.name_last_node('range')
                with self._option():
                    self._subfieldCode_()
                    self.name_last_node('code')
                self._error('no available options')
        with self._optional():
            self._INDEX_()
            self.name_last_node('index')
        with self._optional():
            self._CHARSPEC_()
            self.name_last_node('cspec')
        self.ast._define(
            ['code', 'cspec', 'index', 'range'],
            []
        )

    @tatsumasu()
    def _subfieldSpec_(self):  # noqa
        self._fieldTag_()
        self.name_last_node('tag')
        with self._optional():
            self._INDEX_()
            self.name_last_node('index')
        self._abrSubfieldSpec_()
        self.name_last_node('codes')
        self.ast._define(
            ['codes', 'index', 'tag'],
            []
        )

    @tatsumasu('int')
    def _INDICATOR_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('1')
            with self._option():
                self._token('2')
            self._error('no available options')

    @tatsumasu()
    def _indicatorSpec_(self):  # noqa
        self._fieldTag_()
        self.name_last_node('tag')
        with self._optional():
            self._INDEX_()
            self.name_last_node('index')
        self._token('^')
        self._INDICATOR_()
        self.name_last_node('ind')
        self.ast._define(
            ['ind', 'index', 'tag'],
            []
        )

    @tatsumasu()
    def _comparisonString_(self):  # noqa
        self._token('\\')
        self._cut()
        self._pattern('[\\x21-\\x7a]*')

    @tatsumasu()
    def _operator_(self):  # noqa
        with self._choice():
            with self._option():
                self._token('=')
            with self._option():
                self._token('!=')
            with self._option():
                self._token('~')
            with self._option():
                self._token('!~')
            with self._option():
                self._token('!')
            with self._option():
                self._token('?')
            self._error('no available options')

    @tatsumasu()
    def _abbreviation_(self):  # noqa
        with self._choice():
            with self._option():
                with self._optional():
                    self._INDEX_()
                    self.name_last_node('index')
                self._token('^')
                self._INDICATOR_()
                self.name_last_node('ind')
            with self._option():
                self._abrSubfieldSpec_()
                self.name_last_node('data')
            with self._option():
                self._abrFieldSpec_()
                self.name_last_node('field')
            self._error('no available options')
        self.ast._define(
            ['data', 'field', 'ind', 'index'],
            []
        )

    @tatsumasu()
    def _subTerm_(self):  # noqa
        with self._choice():
            with self._option():
                self._comparisonString_()
                self.name_last_node('cmp')
            with self._option():
                self._indicatorSpec_()
                self.name_last_node('inds')
            with self._option():
                self._subfieldSpec_()
                self.name_last_node('data')
            with self._option():
                self._fieldSpec_()
                self.name_last_node('field')
            with self._option():
                self._abbreviation_()
                self.name_last_node('abr')
            self._error('no available options')
        self.ast._define(
            ['abr', 'cmp', 'data', 'field', 'inds'],
            []
        )

    @tatsumasu()
    def _subTermSet_(self):  # noqa
        with self._optional():
            with self._optional():
                self._subTerm_()
                self.name_last_node('left')
            self._operator_()
            self.name_last_node('op')
        self._subTerm_()
        self.name_last_node('right')
        self.ast._define(
            ['left', 'op', 'right'],
            []
        )

    @tatsumasu()
    def _subSpec_(self):  # noqa
        self._token('{')

        def sep1():
            self._token('|')

        def block1():
            self._subTermSet_()
        self._gather(block1, sep1)
        self.name_last_node('terms')
        self._token('}')
        self.ast._define(
            ['terms'],
            []
        )

    @tatsumasu()
    def _marcSpec_(self):  # noqa
        with self._choice():
            with self._option():
                self._indicatorSpec_()
                self.name_last_node('inds')

                def block2():
                    self._subSpec_()
                self._closure(block2)
                self.name_last_node('subspec')
            with self._option():
                with self._group():
                    self._subfieldSpec_()

                    def block4():
                        self._subSpec_()
                    self._closure(block4)

                    def block5():
                        with self._group():
                            self._abrSubfieldSpec_()

                            def block6():
                                self._subSpec_()
                            self._closure(block6)
                    self._closure(block5)
                self.name_last_node('data')
            with self._option():
                self._fieldSpec_()
                self.name_last_node('field')

                def block9():
                    self._subSpec_()
                self._closure(block9)
                self.name_last_node('subspec')
            self._error('no available options')
        self.ast._define(
            ['data', 'field', 'inds', 'subspec'],
            []
        )


class MarcSpecSemantics(object):
    def start(self, ast):  # noqa
        return ast

    def alphaupper(self, ast):  # noqa
        return ast

    def alphalower(self, ast):  # noqa
        return ast

    def digit(self, ast):  # noqa
        return ast

    def vchar(self, ast):  # noqa
        return ast

    def positiveDigit(self, ast):  # noqa
        return ast

    def positiveInt(self, ast):  # noqa
        return ast

    def fieldTag(self, ast):  # noqa
        return ast

    def position(self, ast):  # noqa
        return ast

    def range(self, ast):  # noqa
        return ast

    def positionOrRange(self, ast):  # noqa
        return ast

    def CHARSPEC(self, ast):  # noqa
        return ast

    def INDEX(self, ast):  # noqa
        return ast

    def fieldSpec(self, ast):  # noqa
        return ast

    def abrFieldSpec(self, ast):  # noqa
        return ast

    def subfieldChar(self, ast):  # noqa
        return ast

    def subfieldCode(self, ast):  # noqa
        return ast

    def subfieldRange(self, ast):  # noqa
        return ast

    def abrSubfieldSpec(self, ast):  # noqa
        return ast

    def subfieldSpec(self, ast):  # noqa
        return ast

    def INDICATOR(self, ast):  # noqa
        return ast

    def indicatorSpec(self, ast):  # noqa
        return ast

    def comparisonString(self, ast):  # noqa
        return ast

    def operator(self, ast):  # noqa
        return ast

    def abbreviation(self, ast):  # noqa
        return ast

    def subTerm(self, ast):  # noqa
        return ast

    def subTermSet(self, ast):  # noqa
        return ast

    def subSpec(self, ast):  # noqa
        return ast

    def marcSpec(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'start'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = MarcSpecParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, MarcSpecParser, name='MarcSpec')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
